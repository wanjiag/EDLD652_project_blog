[
  {
    "path": "posts/2021-03-06-the-most-popular-artists-of-all-time/",
    "title": "The most popular artists of all time.",
    "description": "Looking at the most popular musical artists of all time based on their most popular song.",
    "author": [
      {
        "name": "Wanjia Guo",
        "url": "https://wanjiag.github.io/"
      }
    ],
    "date": "2021-03-06",
    "categories": [
      "visualization",
      "spotify"
    ],
    "contents": "\nData Cleaning\n\n\nartist_data = data %>% \n  select(popularity, artists, year, name) %>% \n  mutate(artists =  gsub(\"\\\\[|\\\\]\", \"\", artists)) %>% \n  separate_rows(artists, sep = \", \") %>% \n  mutate(artists =  gsub(\"'\", \"\", artists)) %>% \n  mutate(artists =  gsub('\"', '', artists))\n\nartist_data_decades = artist_data %>% \n  mutate(year = year - year %% 10 )\n\nfig3_data = artist_data_decades  %>% \n  group_by(year, artists) %>% \n  summarise(mean_popularity = mean(popularity)) %>% \n  arrange(year, desc(mean_popularity)) %>% \n  mutate(rank = 1:n()) %>% \n  filter(rank <= 10)\n\n\nif (exists('top10_df')){\n  remove(\"top10_df\")\n}\n\nfor (curr_year in sort(unique(artist_data_decades$year))){\n  curr_df = artist_data_decades %>% \n    filter(year <= curr_year) %>% \n    group_by(artists) %>% \n    summarise(mean_popularity = max(popularity)) %>% \n    arrange(desc(mean_popularity)) %>% \n    mutate(rank = 1:n()) %>%\n    filter(rank <= 10)\n  \n  if (curr_year == 1920){\n    curr_df$old = TRUE\n  }else {\n    curr_df$old = curr_df$artists %in% pre_df$artists\n  }\n  \n  curr_df$year = curr_year\n\n  if (exists('top10_df')){\n    top10_df = rbind(top10_df, curr_df)\n  }else {\n    top10_df = curr_df\n  }\n  pre_df = curr_df\n}\n\n\n\nFinal Visualization\n\n\np3 = ggplot(top10_df) +  \n  aes(xmin = 0, \n      xmax = mean_popularity,\n      ymin = rank - .45,\n      ymax = rank + .45,\n      y = rank,\n      group = artists,\n      fill = old) + \n  geom_rect(alpha = .7) +\n  scale_x_continuous(  \n    limits = c(-50, 100),\n    breaks = c(0, 20, 40, 60, 80, 100)) + \n  geom_text(hjust = \"right\",  \n            aes(label = artists,\n                color = old),  \n            x = -10) + \n  scale_fill_manual(values=c(\"#CB7BA7\",\"#1273B0\"))+\n  scale_color_manual(values=c(\"#CB7BA7\",\"#1273B0\"))+\n  scale_y_reverse() +\n  labs(x = 'Popularity (0-100)', \n       y = '',\n       title = \"The most popular artists through the decades.\",\n       subtitle = \"<span style = 'color: #CB7BA7'>New comers<\/span>\n       and \n       <span style = 'color: #1273B0'>Defending champions<\/span>\",\n       caption = \"Popularity is based on each artist's most popular song.\") +\n  geom_text(x = 50 , y = -5,\n            aes(label = as.character(year)),\n            size = 40, col = \"grey40\", alpha=0.3) + \n  theme(legend.position = \"none\",\n        plot.subtitle = ggtext::element_markdown(size=18),\n        plot.title = element_text(size=20),\n        plot.caption = element_text(size=12))\n\nanimate(p3 + \n          transition_states(year,\n                            transition_length = 2, \n                            state_length = 4) + \n          enter_fade() +\n          exit_fade(),\n        width = 650, \n        height = 400,\n        nframes = 350, \n        renderer = magick_renderer())\n\n\n\n\nIn general, I liked this version the best because 1) I finally figured out how to slow things down a bit; 2) adding colors makes it easier to detect changes from one decade to the next; 3) with new way of calculating running tops, the transitions are more meaningful and more interesting.\nAttempt 1\n\n\np1 = ggplot(fig3_data) +  \n  aes(xmin = 18 ,  \n      xmax = mean_popularity) +  \n  aes(ymin = rank - .45,  \n      ymax = rank + .45,  \n      y = rank) +  \n  facet_wrap(~ year) +  \n  geom_rect(alpha = .7) +\n  scale_x_continuous(  \n    limits = c(-50, 100),\n    breaks = c(0, 20, 40, 60, 80, 100)) + \n  geom_text(col = \"gray13\",  \n            hjust = \"right\",  \n            aes(label = artists),  \n            x = 10) + \n  scale_y_reverse() + \n  labs(x = 'Popularity (0-100)', y = '')\n\np2 = p1 +  \n  facet_null() + \n  geom_text(x = 50 , y = -5,\n            family = \"Times\",\n            aes(label = as.character(year)),\n            size = 25, col = \"grey18\", alpha=0.5) + \n  aes(group = artists)\n\nanimate(p2 + transition_states(year,\n                               transition_length = 2,\n                               state_length = 5) + \n          enter_fade() +\n          exit_fade(), \n        nframes = 250,\n        renderer = magick_renderer())\n\n\n\n\nThis is an edited version from the draft. One of the major problem I found after I planned to make this figure but had trouble with is the fact that very little people stay within top10 from one year to the next. Therefore, the transition state doesn’t look as nice as a continuous racing chart. The transition look far more sudden than I hoped.\nI also had some trouble with flash green screens with gganimate(). Luckily I was able to find a solution online via using the magick_renderer() function.\nAttempt 2\n\n\np3 = ggplot(top10_df) +  \n  aes(xmin = 0, \n      xmax = mean_popularity,\n      ymin = rank - .45,\n      ymax = rank + .45,\n      y = rank,\n      group = artists) + \n  geom_rect(alpha = .7) +\n  scale_x_continuous(  \n    limits = c(-50, 100),\n    breaks = c(0, 20, 40, 60, 80, 100)) + \n  geom_text(col = \"gray13\",  \n            hjust = \"right\",  \n            aes(label = artists),  \n            x = -10) + \n  scale_y_reverse() +\n  labs(x = 'Popularity (0-100)', y = '') +\n  geom_text(x = 50 , y = -5,\n            aes(label = as.character(year)),\n            size = 35, col = \"grey18\", alpha=0.5)\n\nanimate(p3 + \n          transition_states(year,transition_length = 3, state_length = 4) + \n          #ease_aes(\"sine-in-out\") +\n          enter_fade() +\n          exit_fade(), \n        nframes = 350,\n        renderer = magick_renderer())\n\n\n\n#anim_save(\"popular_artist.gif\", animation = last_animation())\n\n\n\nThis figure is different from the previous in a few perspectives:\nI realized that the ranking makes more sense to be based on max, which means that if an aritist has only one mega-hit, the artist deserves to be on the chart, even if the other songs s/he made is horrible.\nI also realized that the ranking should be based on running rank. In other words, if person A got 100 in 1990, and nobody else reach that score after 1990, it only makes sense to have this person still on top of the chart. However, I was calculating top people based on who is the top for each decades. That was a major mistake! I had to write a for-loop to calculate the running rank, but it’s a pretty straight forward for-loop.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-06T21:26:33-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-03-05-how-does-music-change-over-time/",
    "title": "How does music change over time?",
    "description": "Visualize the differing trends in volume, tempo, energy, and popularity over time.",
    "author": [
      {
        "name": "Wanjia Guo",
        "url": "https://wanjiag.github.io/"
      }
    ],
    "date": "2021-03-05",
    "categories": [
      "visualization",
      "spotify"
    ],
    "contents": "\nData Cleaning\n\n\ndata1 = data %>% \n  select(id, popularity, year, danceability, duration_ms, tempo, speechiness) %>% \n  mutate(popularity = (popularity-min(popularity))/(max(popularity)-min(popularity)),\n         danceability = (danceability-min(danceability))/(max(danceability)-min(danceability)),\n         duration = \n           (duration_ms-min(duration_ms))/(max(duration_ms)-min(duration_ms)),\n         tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)),\n         speechiness = (speechiness-min(speechiness))/(max(speechiness)-min(speechiness))) %>% \n  select(-duration_ms)\n  \n\nfig1_data = data1 %>% select(-year) %>% \n  mutate(danceability = cut(danceability, 100, labels=FALSE),\n         duration = cut(duration, 100, labels=FALSE),\n         tempo = cut(tempo, 100, labels=FALSE),\n         speechiness = cut(speechiness, 100, labels=FALSE)) %>% \n  pivot_longer(cols = danceability:duration, \n               names_to = \"property\") %>% \n  group_by(property, value) %>% \n  summarise(popularity_median = median(popularity)) %>% \n  mutate(property = factor(property, levels=c(\"danceability\",\n                                              \"tempo\",\n                                              \"speechiness\",\n                                              \"duration\"),\n                           labels = c(\"Danceability\",\n                                              \"Tempo\",\n                                              \"Speechiness\",\n                                              \"Duration\")))\n\nfig2_data = data1 %>% \n  mutate(decades = year - year %% 10 ) %>% \n  select(-c(popularity, year)) %>% \n  pivot_longer(cols = danceability:duration, \n               names_to = \"property\") %>% \n  group_by(property, decades) %>% \n  summarise(mean = mean(value)) %>% \n  mutate(property = factor(property, levels=c(\"duration\",\n                                              \"speechiness\",\n                                              \"tempo\",\n                                              \"danceability\")))\n\n\n\n\n\nfig2_data2 = data_by_year %>% \n  select(-c(key, mode)) %>% \n  mutate(acousticness = (acousticness-min(acousticness))/(max(acousticness)-min(acousticness)),\n         danceability = (danceability-min(danceability))/(max(danceability)-min(danceability)),\n         duration = (duration_ms-min(duration_ms))/(max(duration_ms)-min(duration_ms)),\n         energy = (energy-min(energy))/(max(energy)-min(energy)),\n         instrumentalness =\n           (instrumentalness-min(instrumentalness))/(max(instrumentalness)-min(instrumentalness)),\n         liveness = (liveness-min(liveness))/(max(liveness)-min(liveness)),\n         loudness = (loudness-min(loudness))/(max(loudness)-min(loudness)),\n         speechiness = (speechiness-min(speechiness))/(max(speechiness)-min(speechiness)),\n         tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)),\n         valence = (valence-min(valence))/(max(valence)-min(valence)),\n         popularity = (popularity-min(popularity))/(max(popularity)-min(popularity))\n         ) %>% \n  select(-duration_ms) %>% \n  pivot_longer(cols = acousticness:duration, \n               names_to = \"property\")\n\nfig2_data3 = fig2_data2 %>% \n  filter(property %in% c('energy', 'loudness', 'tempo', 'popularity')) %>% \n  mutate(property = factor(property, levels=c('popularity','energy', 'loudness', 'tempo')))\n\n\n\nFinal Visualization:\n\n\nggplot(fig2_data3 %>% \n         filter(property!=\"popularity\"),\n       aes(x=year, y=value)) + \n  geom_line(aes(color=property)) +\n  geom_line(data=fig2_data3 %>% \n              filter(property==\"popularity\"), \n            aes(x=year, y=value), \n            color=\"red\",\n            size=1.3)+\n  gghighlight(use_direct_label = FALSE)+\n  scale_color_OkabeIto(darken=-0.5)+\n  theme(plot.title = ggtext::element_markdown(),\n        legend.position = \"none\")+\n  labs(title = \"Music is \n  <span style = 'color: #57B4E9'>louder<\/span> \n  <span style = 'color: #029E73'>higher tempo<\/span> \n  <span style = 'color: #E69F00'>more energetic<\/span>,\\n\n  but NOT\n  <span style = 'color: #FF2500'>**more popular**<\/span>\")\n\n\n\n\nMy personal favorite part of this figure is the fact that it tells a good story. There are a lot properties I could choose to plot, but it is only interesting when there are contrasts. It is interesting (to me personally) to realize that since 2000, despite the fact that the songs are loud, high tempo, and energtic, they are only dropping in popularity.\nAttempt 1:\n\n\nggplot(fig2_data, aes(x=decades, y=property, fill=mean)) + geom_tile() +\n  scale_fill_viridis_c(option = \"A\") + \n  labs(y=\"Property\", x=\"Decade\") + \n  theme(legend.position = \"top\")\n\n\n\n\nThis is not bad, but also not great. I think the suggestion that I received the most is to rank the property based on the color, so I did that. However, I still feel because I calculated the mean of song’s property, though I normalized scores, the range of each property is still very different, which makes the change within some properties impossible to see.\nAttempt 2:\n\n\nggplot(fig2_data2, aes(x=year, y=value)) + \n  geom_line(aes(color=property)) +\n  gghighlight(use_direct_label = FALSE)+\n  facet_wrap(~property)+\n  theme(legend.position = \"none\")\n\n\n\n\nI realized there is another dataset that is already ranked by year, so I thought I would try to clean that dataset and see if that works better. I also take a look at a lot more properties just to see what properties changes more or are more interesting. I end up thinking I should try to take in the characteristics that are interesting and tell a story. E.g. I found 3 increasing (energy, loudness, tempo) properties as well as 3 decreasing (acousticness, instrumentalness, speechiness) pnes. Popularity and duration are something that people are generally interested in as well.\n\n\n\n",
    "preview": "posts/2021-03-05-how-does-music-change-over-time/how-does-music-change-over-time_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2021-03-06T19:30:20-08:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-03-05-what-kinds-of-songs-are-popular/",
    "title": "What kinds of songs are popular?",
    "description": "Danceability, tempo, speechiness, and duration: what makes a song popular?",
    "author": [
      {
        "name": "Wanjia Guo",
        "url": "https://wanjiag.github.io/"
      }
    ],
    "date": "2021-03-05",
    "categories": [
      "visualization",
      "spotify"
    ],
    "contents": "\nData clearning:\n\n\ndata1 = data %>% \n  select(id, popularity, year, danceability, duration_ms, tempo, speechiness) %>% \n  mutate(popularity = (popularity-min(popularity))/(max(popularity)-min(popularity)),\n         danceability = (danceability-min(danceability))/(max(danceability)-min(danceability)),\n         duration = \n           (duration_ms-min(duration_ms))/(max(duration_ms)-min(duration_ms)),\n         tempo = (tempo-min(tempo))/(max(tempo)-min(tempo)),\n         speechiness = (speechiness-min(speechiness))/(max(speechiness)-min(speechiness))) %>% \n  select(-duration_ms)\n  \n\nfig1_data = data1 %>% select(-year) %>% \n  mutate(danceability = cut(danceability, 100, labels=FALSE),\n         duration = cut(duration, 100, labels=FALSE),\n         tempo = cut(tempo, 100, labels=FALSE),\n         speechiness = cut(speechiness, 100, labels=FALSE)) %>% \n  pivot_longer(cols = danceability:duration, \n               names_to = \"property\") %>% \n  group_by(property, value) %>% \n  summarise(popularity_median = median(popularity)) %>% \n  mutate(property = factor(property, levels=c(\"danceability\",\n                                              \"tempo\",\n                                              \"speechiness\",\n                                              \"duration\"),\n                           labels = c(\"Danceability\",\n                                              \"Tempo\",\n                                              \"Speechiness\",\n                                              \"Duration\")))\n\n\n\nFinal Visualization:\n\n\nggplot(fig1_data, aes(x=value, y=popularity_median, group=property)) + \n  geom_ribbon(aes(ymin = 0, ymax = popularity_median, fill=property), alpha=0.3) + \n  geom_smooth(aes(color=property, fill=property))+\n  labs(x = \"Normalized Value (0-100)\", y = \"Median Popularity (0-100)\") + \n  scale_fill_OkabeIto()+\n  scale_color_OkabeIto(darken=-0.7)+\n  facet_wrap(~property, nrow=1)+\n  ggdark::dark_theme_gray() +\n  theme(legend.position = \"none\") +\n  labs(title = \"Relationship between different song properties and popularity\")\n\n\n\n\nI think I like this version the best because it not only shows the raw data, but also shows the trend. By separating each property into different panels, it makes it a lot easier to see that danceability have a almost linear relationship with popularity, whereas other properties all have a “sweet spot” for a song to be popular.\nAttempt 1:\n\n\nggplot(fig1_data, aes(x=value, y=popularity_median, group=property)) + \n  geom_ribbon(aes(ymin = 0, ymax = popularity_median, fill=property), alpha=0.6) + \n  labs(x = \"Normalized Value (0-100)\", y = \"Median Popularity (0-100)\") + \n  scale_fill_OkabeIto()\n\n\n\n\nOverall, the overlapping part in the figure makes it really hard to distinguish among each property. I also feel it is hard to see the trend because of how noisy the data is.\nAttempt 2:\n\n\nggplot(fig1_data, aes(x=value, y=popularity_median, group=property)) + \n  geom_smooth(aes(color=property, fill=property))+\n  labs(x = \"Normalized Value (0-100)\", y = \"Median Popularity (0-100)\") + \n  scale_fill_OkabeIto()+\n  scale_color_OkabeIto()+\n  facet_wrap(~property)+\n  gghighlight()+\n  theme(legend.position = \"none\")\n\n\n\n\nI also thought maybe I didn’t have to show the original data to make the figure looks cleaner. This second figure focuses on the trend, or the best fit curve based on each property without showing the actual data. However, I still feel showing how noisy the original data is will be meaningful.\n\n\n\n",
    "preview": "posts/2021-03-05-what-kinds-of-songs-are-popular/what-kinds-of-songs-are-popular_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-03-06T19:26:03-08:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to Visualizing Spotify",
    "description": "Welcome to our new blog, Visualizing Spotify. We hope you enjoy \nreading what we have to say!",
    "author": [
      {
        "name": "Wanjia Guo",
        "url": "https://wanjiag.github.io/"
      }
    ],
    "date": "2021-03-05",
    "categories": [
      "others"
    ],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2021-03-05T15:55:47-08:00",
    "input_file": {}
  }
]
